"""
This script was made to display images that were generated by a neural network.
The images will be displayed in fullscreen, with any newly generated/added images automatically being displayed.

Controls:
Escape = stop the script
"""
import os
import cv2
import numpy as np
import json

SUPPORTED_IMAGE_EXTENSIONS = (".png", ".jpg", ".jpeg", ".bmp", ".dib", ".webp", ".sr", ".ras", ".tiff", ".tif")

# Path to the directory where the generated images are located
IMAGE_DIRECTORY = r"factorit_logos_selected"

image_shown = ""
processed_images = set()

# Create a new fullscreen window
cv2.namedWindow("Generated image", cv2.WND_PROP_FULLSCREEN)
cv2.setWindowProperty("Generated image", cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN)

# Detect the screen resolution based on the fullscreen window's size
window_dimensions = cv2.getWindowImageRect("Generated image")
screen_width = window_dimensions[2]
screen_height = window_dimensions[3]


def get_prompt(img_path):
    with open(img_path, 'rb') as file:
        # Check if the file is a PNG file by reading the first 8 bytes (PNG signature)
        signature = file.read(8)
        if signature[:8] != b'\x89PNG\r\n\x1a\n':
            print("Not a valid PNG file")
            return

        metadata = {}
        # Loop over each chunk in the image file
        while True:
            # Read the length of the current chunk
            length_bytes = file.read(4)
            if not length_bytes:
                break
            length = int.from_bytes(length_bytes, byteorder='big')

            # Read info from the chunk
            chunk_type = file.read(4).decode('ascii')
            data = file.read(length)
            crc = file.read(4)  # Cyclic Redundancy Check. Unused, but must be read

            # If it's a tEXt chunk, extract the metadata dictionary
            if chunk_type == 'tEXt':
                key, value = data.split(b'\x00', 1)
                metadata[key.decode('utf-8')] = json.loads(value)

        prompt = ''.join(metadata['prompt']['6']['inputs']['text'])
        return prompt


TEXT_HEIGHT = 30    # pixels


def add_text_to_image(image, text):
    chars_per_line = 110
    text_lines = [text[i:i+chars_per_line] for i in range(0, len(text), chars_per_line)]

    for i, line in enumerate(text_lines, 1):
        text_pos_vert = TEXT_HEIGHT * i
        # First add the black border, then add the white text on top
        cv2.putText(image, line, (0, text_pos_vert), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 0), 6, cv2.LINE_AA)
        cv2.putText(image, line, (0, text_pos_vert), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2, cv2.LINE_AA)


while True:
    # Get all images in the directory
    files = os.listdir(IMAGE_DIRECTORY)
    image_names = [img_file for img_file in files if img_file.lower().endswith(SUPPORTED_IMAGE_EXTENSIONS)]

    current_images = set(image_names)
    new_images = current_images-processed_images

    if len(new_images) > 0:
        for i in new_images:
            image_shown = i
            break
        image_path = os.path.join(IMAGE_DIRECTORY, image_shown)
        img = cv2.imread(image_path)

        # Resize image to fit the screen
        scaling_x = screen_width/img.shape[1]
        scaling_y = screen_height/img.shape[0]
        scaling = min(scaling_x, scaling_y)
        img = cv2.resize(img, (0, 0), fx=scaling, fy=scaling, interpolation=cv2.INTER_LINEAR)

    # Calculate the position to center the image
    x_position = (screen_width - img.shape[1]) // 2
    y_position = (screen_height - img.shape[0]) // 2

    # Create a black canvas (background) with screen dimensions
    background = np.zeros((screen_height, screen_width, 3), dtype=np.uint8)

    # Paste the image on the black canvas at the calculated position
    background[y_position:y_position + img.shape[0], x_position:x_position + img.shape[1]] = img

    # Add the prompt that was used to the image
    prompt = get_prompt(image_path)
    add_text_to_image(background, prompt)

    # Show the image
    cv2.imshow("Generated image", background)

    processed_images = current_images
    # Wait for a short period before checking again
    key_input = cv2.waitKey(5000)
    # If the user pressed the escape key, quit the program
    if key_input == 27:
        break

cv2.destroyAllWindows()

